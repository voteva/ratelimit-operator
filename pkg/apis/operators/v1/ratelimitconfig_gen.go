package v1

// A descriptor is a list of key/value pairs that the rate limit server uses to select
// the correct rate limit to use when limiting. Descriptors are case-sensitive.
// Each descriptor in a descriptor list must have a key. It can also optionally have a value to enable
// a more specific match. The `rate_limit` block is optional and, if present, sets up an actual rate limit rule.
// If the rate limit is not present and there are no nested descriptors, then the descriptor is effectively whitelisted.
// Otherwise, nested descriptors allow more complex matching and rate limiting scenarios.
type Descriptor struct {
	// +kubebuilder:validation:MaxLength=255
	// +kubebuilder:validation:MinLength=1
	Key string `json:"key,omitempty" yaml:"key,omitempty"`
	// +kubebuilder:validation:MaxLength=255
	// +kubebuilder:validation:MinLength=1
	Value string `json:"value,omitempty" yaml:"value,omitempty"`
	RateLimit *RateLimit `json:"rate_limit,omitempty" yaml:"rate_limit,omitempty"`
	// Nested descriptors.
	Descriptors []*Descriptor `json:"descriptors,omitempty" yaml:"descriptors,omitempty"`
	// Each top-level Descriptor defines a new Rate Limit "rule". When a request comes in, rate limit
	// actions are applied to the request to generate descriptor tuples that are sent to the rate limit
	// server. If any rule is triggered then the entire request returns HTTP 429 Too Many Requests.
	//
	// Typically, rule priority is signalled by nesting descriptors, as the most specific rule match for
	// the descriptor tuple generated by the rate limit actions is used. In rare cases this is too restrictive;
	// instead you can set rule priority by setting weights on your descriptors.
	//
	// All rules with the highest weight are processed, if any of these rules trigger rate limiting then the
	// entire request will return a 429. Rules that are not considered for rate limiting are ignored in the
	// rate limit server, and their request count is not incremented in the rate limit server cache.
	//
	// Defaults to 0; thus all rules are evaluated by default.
	Weight uint32 `json:"weight,omitempty" yaml:"weight,omitempty"`
	// A boolean override for rule priority via weighted rules. Any rule with `alwaysApply` set to `true` will
	// always be considered for rate limiting, regardless of the rule's weight. The rule with the highest weight
	// will still be considered. (this can be a rule that also has `alwaysApply` set to `true`)
	//
	// Defaults to false.
	AlwaysApply bool `json:"always_apply,omitempty" yaml:"always_apply,omitempty"`
}

// Each action in the list maps part of the request (or its context) to a descriptor. The tuple of descriptors
// generated by the provided actions is sent to the rate limit server and matched against rate limit rules.
type RateLimitActions struct {
	Actions []*Action `json:"actions,omitempty" yaml:"actions,omitempty"`
}

// A `RateLimit` specifies the actual rate limit that will be used when there is a match.
type RateLimit struct {
	// +kubebuilder:validation:Enum={second,minute,hour,day}
	Unit string `json:"unit" yaml:"unit"`
	// +kubebuilder:validation:Minimum=0
	RequestsPerUnit uint32 `json:"requests_per_unit" yaml:"requests_per_unit"`
}

// Copied directly from envoy
// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-msg-config-route-v3-ratelimit-action
type Action struct {
	SourceCluster      *Action_SourceCluster      `json:"source_cluster,omitempty" yaml:"source_cluster,omitempty"`
	DestinationCluster *Action_DestinationCluster `json:"destination_cluster,omitempty" yaml:"destination_cluster,omitempty"`
	RequestHeaders     *Action_RequestHeaders     `json:"request_headers,omitempty" yaml:"request_headers,omitempty"`
	RemoteAddress      *Action_RemoteAddress      `json:"remote_address,omitempty" yaml:"remote_address,omitempty"`
	GenericKey         *Action_GenericKey         `json:"generic_key,omitempty" yaml:"generic_key,omitempty"`
	HeaderValueMatch   *Action_HeaderValueMatch   `json:"header_value_match,omitempty" yaml:"header_value_match,omitempty"`
}

// The following descriptor entry is appended to the descriptor:
//
// ```
//   ("source_cluster", "<local service cluster>")
// ```
//
// <local service cluster> is derived from the :option:`--service-cluster` option.
type Action_SourceCluster struct{}

// The following descriptor entry is appended to the descriptor:
//
// ```
//   ("destination_cluster", "<routed target cluster>")
// ```
//
// Once a request matches against a route table rule, a routed cluster is determined by one of
// the following `route table configuration (envoy_api_msg_RouteConfiguration)`
// settings:
//
// * `cluster (envoy_api_field_route.RouteAction.cluster)` indicates the upstream cluster
//   to route to.
// * `weighted_clusters (envoy_api_field_route.RouteAction.weighted_clusters)`
//   chooses a cluster randomly from a set of clusters with attributed weight.
// * `cluster_header (envoy_api_field_route.RouteAction.cluster_header)` indicates which
//   header in the request contains the target cluster.
type Action_DestinationCluster struct{}

// The following descriptor entry is appended when a header contains a key that matches the
// *header_name*:
//   ("<descriptor_key>", "<header_value_queried_from_header>")
type Action_RequestHeaders struct {
	// The header name to be queried from the request headers. The header’s
	// value is used to populate the value of the descriptor entry for the
	// descriptor_key.
	HeaderName string `json:"header_name,omitempty" yaml:"header_name,omitempty"`
	// The key to use in the descriptor entry.
	DescriptorKey string `json:"descriptor_key,omitempty" yaml:"descriptor_key,omitempty"`
}

// The following descriptor entry is appended to the descriptor and is populated using the
// trusted address from `x-forwarded-for (config_http_conn_man_headers_x-forwarded-for)`:
//   ("remote_address", "<trusted address from x-forwarded-for>")
type Action_RemoteAddress struct{}

// The following descriptor entry is appended to the descriptor:
//   ("generic_key", "<descriptor_value>")
type Action_GenericKey struct {
	// The value to use in the descriptor entry.
	DescriptorValue string `json:"descriptor_value,omitempty" yaml:"descriptor_value,omitempty"`
}

// The following descriptor entry is appended to the descriptor:
//   ("header_match", "<descriptor_value>")
type Action_HeaderValueMatch struct {
	// The value to use in the descriptor entry.
	DescriptorValue string `json:"descriptor_value,omitempty" yaml:"descriptor_value,omitempty"`
	// If set to true, the action will append a descriptor entry when the
	// request matches the headers. If set to false, the action will append a
	// descriptor entry when the request does not match the headers. The
	// default value is true.
	ExpectMatch *bool `json:"expect_match,omitempty" yaml:"expect_match,omitempty"`
	// Specifies a set of headers that the rate limit action should match
	// on. The action will check the request’s headers against all the
	// specified headers in the config. A match will happen if all the
	// headers in the config are present in the request with the same values
	// (or based on presence if the value field is not in the config).
	Headers []*Action_HeaderValueMatch_HeaderMatcher `json:"headers,omitempty" yaml:"headers,omitempty"`
}

type Action_HeaderValueMatch_HeaderMatcher struct {
	// Specifies the name of the header in the request.
	Name string `json:"name,omitempty" yaml:"name,omitempty"`

	// Specifies how the header match will be performed to route the request.
	ExactMatch   string                                            `json:"exact_match,omitempty" yaml:"exact_match,omitempty"`
	RegexMatch   string                                            `json:"regex_match,omitempty" yaml:"regex_match,omitempty"`
	RangeMatch   *Action_HeaderValueMatch_HeaderMatcher_Int64Range `json:"range_match,omitempty" yaml:"range_match,omitempty"`
	PresentMatch bool                                              `json:"present_match,omitempty" yaml:"present_match,omitempty"`
	PrefixMatch  string                                            `json:"prefix_match,omitempty" yaml:"prefix_match,omitempty"`
	SuffixMatch  string                                            `json:"suffix_match,omitempty" yaml:"suffix_match,omitempty"`

	// If specified, the match result will be inverted before checking. Defaults to false.
	//
	// Examples:
	//
	// * The regex *\d{3}* does not match the value *1234*, so it will match when inverted.
	// * The range [-10,0) will match the value -1, so it will not match when inverted.
	InvertMatch bool `json:"invert_match,omitempty" yaml:"invert_match,omitempty"`
}

// Specifies the int64 start and end of the range using half-open interval semantics [start, end).
type Action_HeaderValueMatch_HeaderMatcher_Int64Range struct {
	// start of the range (inclusive)
	Start int64 `json:"start,omitempty" yaml:"start,omitempty"`
	// end of the range (exclusive)
	End int64 `json:"end,omitempty" yaml:"end,omitempty"`
}
